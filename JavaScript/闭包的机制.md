## 闭包作用域

1. 创建函数

   - 开辟一个堆内存
   - 把函数体中的代码当做字符串存储进去
   - 把堆内存的地址赋值给函数名/变量名
   - **函数在哪创建，那么它执行时候所需要查找的上级作用域就是谁**

2. 函数执行

   - 形成一个全新的私有作用域、执行上下文、私有栈内存(执行一次形成一个，多个之间也不会产生影响)
   - 形参赋值 & 变量提升
   - 代码执行(把所属堆内存中的代码字符串拿出来一行行执行)
   - **遇到一个变量，首先看它是否为私有变量(形参和在私有作用域中声明的变量是私有变量)，是私有的就操作自己的变量即可，不是私有的则向上级作用域中查找... 一直找到全局作用域为止 => 作用域链查找机制**
   - 私有变量和外界的变量没有必然关系，可以理解为被私有栈内存保护起来了，这种机制其实就是**闭包的保护机制**

3. 关于堆栈内存释放问题(以谷歌webkit内核为例)

   > 函数执行就会形成栈内存(从内存中分配的一块空间)，如果内存不销毁释放，很容易就会导致栈内存溢出(内存爆满，电脑就卡死了)，堆栈内存的释放问题是学习JS的核心知识之一

   - 堆内存释放问题

     ```javascript
     // 创建一个引用类型值，就会产生一个堆内存
     // 如果当前创建的堆内存不被其他东西所占用了(浏览器会在空闲的时候，查找每一个内存的引用状况，不被占用的都会给回收释放掉)，则会释放
     ```

   - 栈内存释放





## 闭包的两大作用

1. 保护(私有变量和外部没有必然联系)
2. 保存(形成不销毁的栈内存，里面的私有变量等信息保存下来了)





## this

> 函数执行的主体(不是上下文)：意思是谁把函数执行的，那么执行主体就是谁





